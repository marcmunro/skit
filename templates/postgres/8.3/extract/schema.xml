<?xml version="1.0" encoding="UTF-8"?>

<skit:inclusion
   xmlns:skit="http://www.bloodnok.com/xml/skit"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <skit:let>
    <skit:var name="function_sigs"/>
    <skit:runsql to="alltypes" file="sql/alltypes.sql" hash="oid"/>
    <skit:runsql to="basetypes" file="sql/basetypes.sql" hash="oid"/>
    <skit:runsql to="comptypes" file="sql/comptypes.sql"/>
    <skit:runsql to="domains" file="sql/domains.sql"/>
    <skit:runsql to="constraints" file="sql/constraints.sql"/>
    <skit:runsql to="functions" file="sql/functions.sql" hash="oid"/>
    <xi:include href="skitfile:extract/function_sigs.xml"/>
    <skit:runsql var="schema" file="sql/schemata.sql">
      <schema>
        <skit:attr name="name"/>
        <skit:attr name="owner"/>
        <skit:attr name="comment"/>

        <skit:if test="(not (select tuple 'privs'))">
    	<grant with_grant="yes" priv="create">
    	  <skit:attr name="from" field="owner"/>
    	  <skit:attr name="to" field="owner"/>
    	</grant>
    	<grant with_grant="yes" priv="usage">
    	  <skit:attr name="from" field="owner"/>
    	  <skit:attr name="to" field="owner"/>
    	</grant>
        </skit:if>
        <skit:exec_function name="grants_from_privs"
    			  privileges="(select tuple 'privs')"/>

        <xi:include href="skitfile:extract/domains.xml"/>
        <xi:include href="skitfile:extract/basetypes.xml"/>
        <xi:include href="skitfile:extract/basetypes.xml"/>
        <xi:include href="skitfile:extract/alltypes.xml"/>
        <xi:include href="skitfile:extract/comptypes.xml"/>
        <xi:include href="skitfile:extract/functions.xml"/>
      </schema>
    </skit:runsql>
  </skit:let>
  <!-- <skit:exec expr="(debug 'TODO: operators, operator classes,
  aggregates, sequences, tables' nil)"/> -->
</skit:inclusion>


  <skit:runsql var="operators" file="sql/operators.sql"/>
  <skit:runsql var="operator_classes" file="sql/operator_classes.sql"/>
  <skit:runsql var="opclass_opers" file="sql/opclass_opers.sql"/>
  <skit:runsql var="opclass_funcs" file="sql/opclass_funcs.sql"/>
  <skit:runsql var="aggregates" file="sql/aggregate.sql"/>
  <skit:runsql var="sequences" file="sql/sequences.sql"/>
  <skit:runsql var="tables" file="sql/tables.sql"/>

  <skit:foreach var="functions">
    <skit:expr>
      <!-- Create signature and qname attributes for each function -->
      args = tuple['argtype_oids'].split      
      args.map! do |arg|
        type = Globals['alltypes'][arg]
        schema = type['schema']
        name = type['name']
        if schema == 'pg_catalog'
          name
        else
          schema + '.' + name
        end
      end
      sig = tuple['schema'] + '.' + tuple['name'] + '(' +
            args.join(',') + ')'
      tuple['signature'] = sig
      qname = '&quot;' + sig.gsub(/([\.,()])/, '&quot;\1&quot;') + '&quot;'
      tuple['qname'] = qname.gsub(/&quot;&quot;/, '')
    </skit:expr>
  </skit:foreach>

  <skit:foreach var="schemas">
    <schema>
      
      <skit:foreach var="domains"
		       filter="tuple['schema'] == tuple.parent['name']">
	<domain>
	  <skit:foreach var="constraints"
			   filter="tuple['oid'] == tuple.parent['conoid']">
	    <constraint>
	      <skit:attr field="name"/>
	      <skit:attr field="schema"/>
	      <skit:attr field="constraint_type"/>
	      <skit:attr field="source"/>
	    </constraint>
	  </skit:foreach>
	</domain>
      </skit:foreach>

      <skit:foreach var="comptypes"
		       filter="tuple['schema'] == tuple.parent['name']">
	<type>
	  <skit:attr field="name"/>
	  <skit:attr field="schema"/>
	  <skit:attr field="type"/>
	  <skit:attr field="owner"/>
	  <skit:attr field="comment"/>
	  <skit:runsql var="typcolumns" file="sql/type_columns.sql"
			  param_1="tuple['reloid']">
	    <column>
	      <skit:copytuple/>
	    </column>
	  </skit:runsql>
	</type>
      </skit:foreach>
	  
      <!-- Note: basetypes are post-processed into types by 
	   post_extract.xsl -->
      <skit:foreach var="basetypes"
		       filter="tuple['schema'] == tuple.parent['name']">
	<basetype>
	  <skit:copytuple/>
	</basetype>
      </skit:foreach>
	    
      <skit:foreach var="functions"
      		 filter="tuple['schema'] == tuple.parent['name']">
        <function>	
          <skit:attr field="name"/>
          <skit:attr field="schema"/>
          <skit:attr field="owner"/>
          <skit:attr field="language"/>
          <skit:attr field="security_definer"/>
          <skit:attr field="is_strict"/>
          <skit:attr field="returns_set"/>
          <skit:attr field="volatility"/>
          <skit:attr field="argtypes"/>
          <skit:attr field="bin"/>
          <skit:attr field="privs"/>
          <skit:attr field="comment"/>
          <skit:attr field="signature"/>
          <skit:attr field="qname"/>   <!-- TODO: Remove this -->
          <skit:attr field="oid"/>	  <!-- TODO: Remove this -->
          
          <!-- Figure out parameter information -->
          <skit:expr>
            args = tuple['argtype_oids'].split
            modes, names = nil, nil
            if x = tuple['all_argmodes']
              modes = x.gsub(/[{}]/, "").split(',')
            end
            if x = tuple['all_argnames']
              names = x.gsub(/[{}]/, "").split(',')
            end
            params = []
            for i in 0 .. (args.length - 1)
              param = {}
              SkitTuple.maketuple(param)  ## TODO: Refactor this away!
              oid = args[i]
              type = Globals['alltypes'][oid]
              param['position'] = (i + 1).to_s
              param['type_name'] = type['name']
              param['type_schema'] = type['schema']
              param['mode'] = 
                if modes
                  case modes[i]
                  when 'i' then 'in' 
                  when 'b' then 'inout'
                  else 'out' 
                  end
                else
                  'in'
                end
              if names then param['name'] = names[i] end
              params[i] = param
            end
            res_oid = tuple['result_type_oid']
            restype = Globals['alltypes'][res_oid]
            Globals['result'] = restype
            Globals['params'] = params
          </skit:expr>

          <skit:foreach var="params">
            <param>
      	      <skit:copytuple/>
            </param>
          </skit:foreach>  
          <result>
            <skit:attr id="type_schema" 
      		    expr="Globals['result']['schema']"/>
            <skit:attr id="type_name" expr="Globals['result']['name']"/>
            <skit:if test="tuple['returns_set']">
      	      <skit:attr field="returns_set"/>
            </skit:if>
          </result>
      		  
          <!-- If this function is a handler for a user-defined type -->
          <skit:if test="tuple['type_handler_oid']">
            <skit:expr>
      	      oid = tuple['oid']
      	      input_oid = tuple['type_input_oid']
      	      output_oid = tuple['type_output_oid']
      	      if input_oid == oid
      	        follows_fn = nil
      	      elsif output_oid == oid
      	        follows_fn = Globals['functions'][input_oid]['signature']
      	      else
      	        follows_fn = Globals['functions'][output_oid]['signature']
      	      end
      	      type_oid = tuple['type_handler_oid']
                    type = Globals['alltypes'][type_oid]
      	      tuple['type_schema'] = type['schema']
      	      tuple['type_name'] = type['name']
            </skit:expr>
            <handler_for>
      	      <skit:attr field="following_schema"/>
      	      <skit:attr field="following"/>
      	      <skit:attr field="type_schema"/>
      	      <skit:attr field="type_name"/>
            </handler_for>
          </skit:if>

          <source>
            <skit:text field="source"/>
          </source>

          <skit:if test="!tuple['privs']">
            <!-- No privileges defined for this function, so create
      	   grants for the implicit privs -->
            <grant with_grant="yes" priv="execute">
      	      <skit:attr id="from" field_expr="#{owner}"/>
      	      <skit:attr id="to" field_expr="#{owner}"/>
            </grant>
          </skit:if>
          <skit:foreach split="privs">
            <skit:pg_eachpriv field="privs" 
      			   toname="to" privname="priv" fromname="from"
      			   withname="with_grant">
      	      <grant>
      		<skit:if test="tuple['to'] == tuple['from']">
      		  <!-- If this is the implied grant to the owner,
      		       then they have with_grant="yes" -->
      		  <skit:attr id="with_grant" expr="'yes'"/>
      		</skit:if>
      		<skit:if test="tuple['to'] != tuple['from']">
      		  <skit:attr field="with_grant"/>
      		</skit:if>
      		<skit:attr field="priv"/>
      		<skit:attr field="from"/>
      		<skit:attr field="to"/>
      	      </grant>
            </skit:pg_eachpriv>
          </skit:foreach>
        </function>
      </skit:foreach>

      <skit:foreach var="operators"
      		 filter="tuple['schema'] == tuple.parent['name']">
        <skit:expr>
          <!-- Create signature and params attributes -->
          params = '(' + tuple['leftarg_schema'] + '.' + tuple['leftarg'] + 
                   ',' + tuple['rightarg_schema'] + '.' + 
                   tuple['rightarg'] + ')'
          sig = tuple['schema'] + '.' + tuple['name'] + params
          tuple['params'] = params
          tuple['signature'] = sig
          if (oid = tuple['procedure_oid']) and (oid != '0')
            if func = Globals['functions'][oid]
              tuple['procedure_signature'] = func['signature']
            else
              raise "NO SIG FN FOR #{oid}, TYPE #{tuple['name']}"
            end
          end
          if (oid = tuple['restrict_oid']) and (oid != '0')
            if func = Globals['functions'][oid]
              tuple['restrict_signature'] = func['signature']
            else
              raise "NO SIG FN FOR #{oid}, TYPE #{tuple['name']}"
            end
          end
          if (oid = tuple['join_oid']) and (oid != '0')
            if func = Globals['functions'][oid]
              tuple['join_signature'] = func['signature']
            else
              raise "NO SIG FN FOR #{oid}, TYPE #{tuple['name']}"
            end
          end
        </skit:expr>

        <operator>
          <skit:copytuple/>
        </operator>
      </skit:foreach>
	  
      <!-- The following stylesheet call formats parameters and
	   generates sql lookups for converting type oids to names. -->
      
      <skit:foreach var="aggregates"
		       filter="tuple['schema'] == tuple.parent['name']">

	<skit:expr>
	  <!-- Create signature attributes -->
	  if oid = tuple['trans_oid']
	    if oid != '0'
	      if func = Globals['functions'][oid]
	        tuple['transition_signature'] = func['signature']
	      else
	        raise "NO SIG FN FOR #{oid}, AGGREGATE #{tuple['name']}"
	      end
            end
	  end
	  if oid = tuple['final_oid']
	    if oid != '0'
	      if func = Globals['functions'][oid]
	        tuple['final_signature'] = func['signature']
	      else
	        raise "NO SIG FN FOR #{oid}, AGGREGATE #{tuple['name']}"
	      end
	    end
	  end
	</skit:expr>
	<aggregate>	
	  <skit:copytuple/>
	</aggregate>
      </skit:foreach>

      <skit:foreach var="operator_classes"
		       filter="tuple['schema'] == tuple.parent['name']">
	<operator_class>
	  <skit:copytuple/>
	  <skit:foreach var="opclass_opers"
			   filter="tuple['opclass_oid'] == tuple.parent['oid']">
	    <opclass_oper>
	      <skit:attr field='strategy'/>
	      <skit:attr field='op_name'/>
	      <skit:attr field='op_schema'/>
	      <skit:attr field='op_leftarg_name'/>
	      <skit:attr field='op_leftarg_schema'/>
	      <skit:attr field='op_rightarg_name'/>
	      <skit:attr field='op_rightarg_schema'/>
	    </opclass_oper>
	  </skit:foreach>
	  <skit:foreach var="opclass_funcs"
			   filter="tuple['opclass_oid'] == tuple.parent['oid']">
	    <skit:expr>
	      proc_oid = tuple['proc_oid']
	      func = Globals['functions'][proc_oid]
	      tuple['function_signature'] = sig = func['signature']
	      tuple['function_qname'] = sig_to_qname(sig)
	    </skit:expr>
	    <opclass_func>
	      <skit:copytuple/>
	      <!-- <skit:attr id="proc_num" field="proc_num"/>
	      <skit:attr id="proc_oid" field="proc_oid"/> -->
	    </opclass_func>
	  </skit:foreach>
	</operator_class>
      </skit:foreach>
	  
      <skit:foreach var="sequences"
		       filter="tuple['schema'] == tuple.parent['name']">
	<skit:expr>
	  sig = tuple['schema'] + '.' + tuple['name']
	  tuple['qname'] = sig_to_qname(sig)
	</skit:expr>
	<sequence>
	  <skit:attribute field="name"/>
	  <skit:attribute field="schema"/>
	  <skit:attribute field="owner"/>
	  <skit:attribute field="comment"/>
	  <skit:attribute field="privs"/>
	  <skit:runsql var="seq_attributes" file="sql/sequence_cols.sql"
			  param_1="tuple['qname']">
	    <skit:attribute field="start_with"/>
	    <skit:attribute field="increment_by"/>
	    <skit:attribute field="max_value"/>
	    <skit:attribute field="min_value"/>
	    <skit:attribute field="cache"/>
	    <skit:attribute field="is_cycled"/>
	  </skit:runsql>
          <skit:if test="!tuple['privs']">
	    <grant with_grant="yes" priv="trigger">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	    <grant with_grant="yes" priv="references">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	    <grant with_grant="yes" priv="rule">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	    <grant with_grant="yes" priv="delete">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	    <grant with_grant="yes" priv="insert">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	    <grant with_grant="yes" priv="select">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	    <grant with_grant="yes" priv="update">
	      <skit:attr id="from" field_expr="#{owner}"/>
	      <skit:attr id="to" field_expr="#{owner}"/>
	    </grant>
	  </skit:if>
          <skit:foreach split="privs">
            <skit:pg_eachpriv field="privs" 
      			   toname="to" privname="priv" fromname="from"
      			   withname="with_grant">
	      <grant>
      		<skit:if test="tuple['to'] == tuple['from']">
      		  <!-- If this is the implied grant to the owner,
      		       then they have with_grant="yes" -->
      		  <skit:attr id="with_grant" expr="'yes'"/>
      		</skit:if>
      		<skit:if test="tuple['to'] != tuple['from']">
      		  <skit:attr field="with_grant"/>
      		</skit:if>
      		<skit:attr field="priv"/>
      		<skit:attr field="from"/>
      		<skit:attr field="to"/>
	      </grant>
	    </skit:pg_eachpriv>
	  </skit:foreach>
	</sequence>
      </skit:foreach>

      <skit:include file="extract/tables.xml"/>
    </schema>
  </skit:foreach>


<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
